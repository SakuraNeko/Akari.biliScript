// {{Depend : Akari}} //

/* 命名空间: Akari.Utilities
 * 提供与展示内容并不直接相关的一些工具类。
 */
Akari.Utilities = {};

/* 静态类: Factory
 * 提供创建和操纵对象的方法。
 * 因为历史原因使用此命名（参见：2012/11/21更新）
 */
Akari.Utilities.Factory =
{
  /* 函数: collapse
   * 将给出的所有数组连接为一个。
   *
   * arrays
   *   一个数组的数组。
   */
  collapse : function( arrays )
  {
    var result = [];
    
    for ( var i = 0; i < arrays.length; i ++ )
    {
      result = result.concat( arrays[ i ] );
    }
    
    return result;
  },
  
  /* 函数: extend
   * 将所有属性从source复制到destination对象。
   *
   * destination
   *   目标对象。
   * source
   *   源对象。
   */
  extend : function( destination, source )
  {
    // Iterate through the source
    foreach ( source, function( key, object )
    {
      destination[ key.toString() ] = object;
    });
    
    return destination;
  },
  
  /* 函数: clone
   * 复制一个对象。
   *
   * object
   *   要复制的对象。
   */
  clone : function( object, scope )
  {
    // 检测是否已经定义了自己的clone函数
    if ( object.hasOwnProperty( "clone" ) )
    {
      return object.clone();
    }
    else if ( typeof object === "function" )
    {
      return function() { return object.apply( scope, arguments ); };
    }
    else
    {
      // 迭代运行这个复制函数
      var newObject = {};
      var countProperties = 0;

      foreach ( object, function( key, object )
      {
        countProperties ++;
        
        if ( typeof object === "function" )
        {
          newObject[ key ] = function() { return object.apply( newObject, arguments ); };
        }
        else
        {
          var adg = Akari.Utilities.Factory.clone( object );
          newObject[ key ] = adg;
        }
      });
      
      // 检查newObject是否为空
      if ( countProperties === 0 )
      {
        // 如为空，则可能是AS3对象或者根本就是空的，执行内建的clone函数
        newObject = clone( object );
        
        // 检查是否是DisplayObjectContainer
        if ( object.hasOwnProperty( "numChildren" ) )
        {
          for ( var i = 0; i < object.numChildren; i ++ )
          {
            newObject.addChild( Akari.Utilities.Factory.clone( object.getChildAt( i ) ) );
          }
        }
        
        // 检查是否是Shape
        if ( object.hasOwnProperty( "graphics" ) )
        {
          // 复制graphics的内容
          newObject.graphics.copyFrom( object.graphics );
        }
      }
      
      return newObject;
    }
  },
  
  /* 函数: replicate
   * 返回一组根据给出的参数创建的对象。
   *
   * constructor
   *   要复制的类的构造器。
   * count
   *   要复制的个数。
   * paramsFunction
   *   一个返回参数数组的函数。
   */
  replicate : function( constructor, count, paramsFunction )
  {
    var objects = [];
    
    var i = 0;
    for ( i = 0; i < count; i ++ )
    {
      var newParams;
      
      newParams = paramsFunction ? paramsFunction( i ) : [];
      
      objects.push( constructor.apply( this, newParams ) );
    }
    
    return objects;
  }
};

/* 静态类: Timer
 * 通过采样每帧的时间使用提供比Player.time更加精准的时间，目的是在保证可跳转性的同时提高流畅度。
 */
Akari.Utilities.Timer = function()
{
  var lastTime = 0;
  var deltaTime = 0;
  var sampleCount = 1;
  
  return
  {
    time : 0,
    
    /* 函数: update
     * 计入一帧并更新时间。
     */
    update : function()
    {
      if ( Player.time != lastTime )
      {
        // 防止时间的巨大变化
        if ( Math.abs( Player.time - lastTime ) < 1000 )
        {
          deltaTime = ( Player.time - lastTime ) / sampleCount;
          lastTime = Player.time;
          sampleCount = 1;
          
          this.time = Player.time;
        }
        else
        {
          // 因为可能的跳转重置Timer（或者有可能是执行太慢以至于Timer失去意义）
          deltaTime = 0;
          lastTime = Player.time;
          sampleCount = 1;
          
          this.time = Player.time;
        }
      }
      else
      {
        this.time = lastTime + deltaTime * sampleCount;
        sampleCount ++;
      }
    }
  };
}();

/* 类: Binder
 * 提供绑定属性值得功能，主要在Layer中使用。
 *
 * object
 *   目标对象。
 * properties
 *   含有绑定信息的对象。
 * overridePathCheck
 *   [默认] false
 *   设定这个值将会取消路径检查，这样就可以向目标对象添加新属性。
 *   因为对AS3对象无法添加属性(Error #1056)，所以加入了路径检查的保护机制。请仅在需要功能时打开。
 */
Akari.Utilities.Binder = function()
{
  var binderClass = function( params )
  {
    var needBinding = {};
    
    var pathCheck = function( object, name )
    {
      if ( params.overridePathCheck ) return true;
      
      var dotIndex = name.indexOf(".");
      if ( dotIndex < 0 )
      {
        return object.hasOwnProperty( name );
      }
      else
      {
        return object.hasOwnProperty( name.substring( 0, dotIndex ) ) && pathCheck( object[ name.substring( 0, dotIndex ) ], name.substring( dotIndex + 1 ));
      }
    };
    
    var setParam = function( object, name, value )
    {
      var dotIndex = name.indexOf(".");
      if ( dotIndex < 0 )
      {
        object[ name ] = value;
      }
      else
      {
        setParam( object[ name.substring( 0, dotIndex ) ], name.substring( dotIndex + 1 ), value );
      }
    };
    
    var setBinding = function( name, value )
    {
      // 检查路径是否存在
      if ( !pathCheck( params.object, name ) )
      {
        return;
      }
      
      // 检查有没有必要每帧设定值
      if ( typeof( value ) === "function" )
      {
        needBinding[ name ] = value;
      }
      else
      {
        setParam( params.object, name, value );
      }
    };
    
    var setBindings = function( key, obj )
    {
      // 查出可能的Link或者Sequence
      if ( obj.hasOwnProperty( "linkFunc" ) )
      {
        // 是否有使用函数
        if ( obj.linkFunc )
        {
          if ( typeof( params.properties[ obj.name.toString() ] ) === "function" )
          {
            setBinding( key, function( time )
            {
              var value = params.properties[ obj.name.toString() ].apply( this, [ time ] );
              return obj.linkFunc.apply( this, [ value, time ] );
            });
          }
          else
          {
            setBinding( key, function( time )
            {
              return obj.linkFunc.apply( this, [ params.properties[ obj.name.toString() ], time ] );
            });
          }
        }
        else
        {
          setBinding( key, params.properties[ obj.name.toString() ] );
        }
      }
      else if ( obj.hasOwnProperty( "sequence" ) )
      {
        // 先设定顺序
        for ( var i = 0; i < obj.sequence.length; i ++ )
        {
          setBindings( obj.sequence[ i ][ 0 ], obj.sequence[ i ][ 1 ] );
        }
        
        setBindings( key, obj.value );
      }
      else
      {
        setBinding( key, obj );
      }
    };
    
    foreach( params.properties, setBindings );
    
    return
    {
      
      /* 函数: update
       * 更新目标对象以与时间轴相合。
       *
       * time
       *   Number，时间轴上的当前时间（毫秒）。
       * scope
       *   [默认] object
       *   执行函数的上下文对象。
       */
      update : function( time, scope )
      {
        foreach( needBinding, function( key, obj )
        {
          setParam( params.object, key, obj.apply( scope || params.object, [ time ] ) );
        });
      }
    };
  };

  /* 类: Binder.Link
   * 表示不同属性间的一个链接。
   *
   * name
   *   要连接的属性的名字。
   * linkFunc
   *   [默认] null
   *   接受链接属性的值和时间的函数，若null则表示复制链接属性的值。
   */
  binderClass.Link = function( params )
  {
    return
    {
      name : params.name,
      linkFunc : params.linkFunc || null
    };
  };

  /* 类: Binder.Sequence
   * 表示一个顺序化得设定。在需要前置设置的属性上使用。
   *
   * sequence
   *   一个含有名/值对的数组。
   * value
   *   在顺序设定完后需要设定的属性。
   */
  binderClass.Sequence = function( params )
  {
    return
    {
      sequence : params.sequence,
      value : params.value
    };
  };
  
  return binderClass;
}();
