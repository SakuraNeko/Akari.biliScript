// {{Depend : Akari}} //
// {{Depend : Akari.Utilities}} //
// {{Depend : Akari.Display}} //

/* 命名空间: Akari.Display.Text
 * 用于显示矢量文字的类。
 */
Akari.Display.Text = {};

/* 枚举: RangeShape
 * RangeSelector的定型函数。
 */
Akari.Display.Text.RangeShape =
{
  square : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 0;

    return 1;
  },

  triangle : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 0;

    if ( proportion < this.offset + ( this.start + this.end ) / 2 )
    {
      return ( proportion - this.offset - this.start ) * 2 / ( this.end - this.start );
    }

    return ( this.end + this.offset - proportion ) * 2 / ( this.end - this.start );
  },

  rampUp : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 1;

    return ( proportion - this.offset - this.start ) / ( this.end - this.start );
  },

  rampDown : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 1;
    if ( proportion > this.end + this.offset ) return 0;

    return ( this.end + this.offset - proportion ) / ( this.end - this.start );
  }
};

/* 类: RangeSelector
 * 一个通过字符在字符串中的位置选择字符的Selector。
 *
 * basis
 *   [默认] "characters"
 *   设置选择的基准。可能值："characters", "lines".
 * shapingFunc
 *   [默认] RangeShape.square
 *   一个将比例映射到0 - 1的效果参数的函数，决定了范围的形状。
 * properties
 *   [默认] {
 *               start : 0,
 *               end : 1,
 *               offset : 0,
 *               shapingFunc : RangeShape.square
 *             }
 *   选择器属性的Bindings使用比例作为单位。
 */
Akari.Display.Text.RangeSelector = function( params )
{
  var props =
  {
    start : 0,
    end : 1,
    offset : 0
  };
  var propsBinder = Akari.Utilities.Binder({ object: props, properties : params.properties });

  var shapingFunc = params.shapingFunc || Akari.Display.Text.RangeShape.square;
  
  // 判断是否需要在字符基准上执行
  if ( !params.basis || params.basis === "characters" )
  {
    return
    {
      select : function( time, linesContainer, callback )
      {
        propsBinder.update( time );
        
        // 记录当前的位置以获得比例
        var accumIndex = 0;
        var length = 0;
        
        // 初次枚举linesContainer来获得总数
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          length += ( linesContainer.getChildAt( lineIndex ) ).numChildren;
        }
        
        // 二次枚举linesContainer进行改变
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          var line = linesContainer.getChildAt( lineIndex );
          
          for ( var charIndex = 0; charIndex < line.numChildren; charIndex ++ )
          {
            callback( line.getChildAt( charIndex ), shapingFunc.apply( props, [ ( accumIndex + charIndex ) / length ] ) );
          }
          
          accumIndex += line.numChildren;
        }
      }
    };
  }
  else
  {
    return
    {
      select : function( time, linesContainer, callback )
      {
        propsBinder.update( time );
        
        // 枚举linesContainer进行改变
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          var line = linesContainer.getChildAt( lineIndex );

          callback( line, shapingFunc.apply( props, [ lineIndex / linesContainer.numChildren ] ) );
        }
      }
    };
  }
};

/* 类: Animator
 * 被DynamicVectorTextLayer用于逐字动画。
 *
 * selector
 *   一个决定Animator的效果范围的Selector。
 * bindings
 *   一个决定范围内字符行为的Bindings对象。
 * blendingFunc
 *   [默认] function( value1, value2, effectFactor ) { return value1 + value2 * effectFactor; }
 *   将动画器产生的值与原值进行合并的函数。
 */
Akari.Display.Text.Animator = function( params )
{
  // 使用空对象存储新的参数
  var props = {};
  var propsBinder = Akari.Utilities.Binder({ object : props, properties : params.bindings, overridePathCheck : true });

  var blendingFunc = params.blendingFunc || function( value1, value2, effectFactor ) { return value1 + value2 * effectFactor; };
  
  // Selector使用的私有回调函数
  var selectCallback = function( object, effectFactor )
  {
    foreach( props, function( key, value )
    {
      // 检查key是否存在，以便继续使用非存在属性
      if ( object.hasOwnProperty( key ) )
      {
        // 因为try/catch并不工作所以在这里不行检查，用户责任
        object[ key ] = blendingFunc( object[ key ], props[ key ], effectFactor );
      }
    });
  };
  
  return
  {
    apply : function( time, linesContainer )
    {
      propsBinder.update( time );

      params.selector.select( time, linesContainer, selectCallback );
    }
  };
};

/* 类: DynamicVectorTextLayer
 * 为了显示基本的动态矢量文字而特化的层（超过200px的大小或者奇特的字体）
 *
 * dictionary
 *   一个含有类似function( graphics ){ }的创建可能的字符的函数的对象。
 *   字符应该是用户提供的，在左上定位并为200px大。
 * textProperties
 *   [默认] { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" }
 *   一个含有矢量文字属性的Bindings对象。
 *   如果fixedWidth为真，文字距离将总是fontSize + letterSpacing，或者( fontSize / 2 ) + letterSpacing中离实际宽度更近的一个。
 * inPoint
 *   一个数字，层进入的时间点（毫秒）。
 * outPoint
 *   一个数字，层退出的时间点（毫秒）。
 * properties
 *   [默认] {}
 *   含有AS3属性的Bindings对象。
 * animators
 *   [默认] []
 *   为逐字动画使用的Animators。如果使用将导致字符在每一帧被重新编排。
 */
Akari.Display.Text.DynamicVectorTextLayer = function( params )
{
  // 创建用于对齐的Sprite
  var linesContainer = Akari.Display.Sprite();
  var alignmentContainer = Akari.Display.Sprite();
  alignmentContainer.addChild( linesContainer );
  
  // 创建用于变化检测的对象，因为缺乏getter/setter的支持。
  var lastTextProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  
  var textProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  var textPropertiesBinder = Akari.Utilities.Binder({ object : textProperties, properties : params.textProperties || {} });
  
  var animators = params.animators || [];
  
  var layer = Akari.Display.Layer(
  {
    source : alignmentContainer,
    inPoint : params.inPoint,
    outPoint : params.outPoint,
    properties : params.properties
  });
  
  // 模拟类继承关系。
  var baseUpdate = Akari.Utilities.Factory.clone( layer.update, layer );
  
  layer.update = function( time )
  {
    baseUpdate( time );
      
    // 更新Binder，并检测是否有改动。
    textPropertiesBinder.update( time, layer.getBinderScope() );

    var needGlyphReset = ( textProperties.text != lastTextProperties.text );
    var needGlyphAdjust = ( params.animators.length > 0 ) || needGlyphReset || ( textProperties.letterSpacing != lastTextProperties.letterSpacing ) || ( textProperties.fontSize != lastTextProperties.fontSize );
    var needAlignmentAdjust = ( params.animators.length > 0 ) || needGlyphAdjust || ( textProperties.horizontalAlign != lastTextProperties.horizontalAlign ) || ( textProperties.verticalAlign != lastTextProperties.verticalAlign ) || ( textProperties.lineHeight != lastTextProperties.lineHeight );

    if ( needAlignmentAdjust ) lastTextProperties = Akari.Utilities.Factory.clone( textProperties );

    // 如果需要则重置字符（最为昂贵）
    if ( needGlyphReset )
    {
      while ( linesContainer.numChildren > 0 ) linesContainer.removeChildAt( 0 );
      
      // 按照行分离文字以处理
      var lines = textProperties.text.split( "\n" );
      
      for ( var numLine = 0; numLine < lines.length; numLine ++ )
      {
        // 为每行创建一个新的Sprite
        var lineSprite = Akari.Display.Sprite();
        
        for ( var numChar = 0; numChar < lines[ numLine ].length; numChar ++ )
        {
          // 将字符插入当前行。位置会在之后编排。
          var glyphShape = Akari.Display.Shape();
          params.dictionary[ lines[ numLine ].charAt( numChar ) ]( glyphShape.graphics );
          lineSprite.addChild( glyphShape );
        }
        
        linesContainer.addChild( lineSprite );
      }
    }

    // 如需要则重新编排字符
    if ( needGlyphAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        var accumulativeX = 0;
        
        for ( var numChar = 0; numChar < lineSprite.numChildren; numChar ++ )
        {
          var glyph = lineSprite.getChildAt( numChar );

          // 重置字符位置，这样字符就不会在应用Animator的情况下“飘走”。
          glyph.transform.matrix3D = null;
          mx = glyph.transform.matrix;
          mx.identity();
          glyph.transform.matrix = mx;
          
          glyph.x = accumulativeX;
          glyph.scaleX = glyph.scaleY = textProperties.fontSize / 200.0;
          
          if ( textProperties.fixedWidth )
          {
            var nwFactor = Math.round( glyph.width / textProperties.fontSize );
            accumulativeX += textProperties.fontSize * ( nwFactor / 2 + 0.5 ) + textProperties.letterSpacing;
          }
          else
          {
            accumulativeX += glyph.width + textProperties.letterSpacing;
          }
        }
      }
    }
    
    // 如需要则调整对齐
    if ( needAlignmentAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        
        // 设置行高和对齐
        switch ( textProperties.horizontalAlign )
        {
          case "left":
            lineSprite.x = 0;
            break;
          case "right":
            lineSprite.x = - lineSprite.width;
            break;
          case "center":
            lineSprite.x = - lineSprite.width / 2;
            break;
        }
        lineSprite.y = numLine * textProperties.lineHeight;
      }
      
      // 设置纵向对齐
      switch ( textProperties.verticalAlign )
      {
        case "top":
          linesContainer.y = 0;
          break;
        case "bottom":
          linesContainer.y = - linesContainer.height;
          break;
        case "center":
          linesContainer.y = - linesContainer.height / 2;
          break;
      }
    }

    // 如需要则应用Animator更新
    if ( params.animators.length > 0 )
    {
      for ( var animatorIndex = 0; animatorIndex < params.animators.length; animatorIndex ++ )
      {
        params.animators[ animatorIndex ].apply( time, linesContainer );
      }
    }
  };
    
  /* 函数: clone
   * 自定义的复制函数。
   */
  layer.clone = function()
  {
    return Akari.Display.Text.DynamicVectorTextLayer( Akari.Utilities.Factory.clone( params ) );
  };

  // 初次更新以避免层内容闪动，
  layer.update( params.inPoint );
  
  return layer;
};