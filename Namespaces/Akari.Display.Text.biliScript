// {{Depend : Akari}} //
// {{Depend : Akari.Utilities}} //
// {{Depend : Akari.Display}} //

/* Namespace: Akari.Display.Text
 * Classes for displaying vector text.
 */
Akari.Display.Text = {};

/* Enum: RangeShape
 * Shaping functions for RangeSelector.
 */
Akari.Display.Text.RangeShape =
{
  square : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 0;

    return 1;
  },

  triangle : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 0;

    if ( proportion < this.offset + ( this.start + this.end ) / 2 )
    {
      return ( proportion - this.offset - this.start ) * 2 / ( this.end - this.start );
    }

    return ( this.end + this.offset - proportion ) * 2 / ( this.end - this.start );
  },

  rampUp : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 0;
    if ( proportion > this.end + this.offset ) return 1;

    return ( proportion - this.offset - this.start ) / ( this.end - this.start );
  },

  rampDown : function( proportion )
  {
    if ( proportion < this.start + this.offset ) return 1;
    if ( proportion > this.end + this.offset ) return 0;

    return ( this.end + this.offset - proportion ) / ( this.end - this.start );
  }
};

/* Class: RangeSelector
 * A Selector that selects characters by their place in the string.
 *
 * basis
 *   [default] "characters"
 *   Specifies the basis of the selection. Possible values: "characters", "lines".
 * shapingFunc
 *   [default] RangeShape.square
 *   A function that maps proportion to 0 - 1 effect factor values, deciding the range's shape, hence the name.
 * properties
 *   [default] {
 *               start : 0,
 *               end : 1,
 *               offset : 0,
 *               shapingFunc : RangeShape.square
 *             }
 *   Bindings for selector properties, units are proportion. shapingFunc converts proportion to effectFactor used by blendingFunc.
 */
Akari.Display.Text.RangeSelector = function( params )
{
  var props =
  {
    start : 0,
    end : 1,
    offset : 0
  };
  var propsBinder = Akari.Utilities.Binder({ object: props, properties : params.properties });

  var shapingFunc = params.shapingFunc || Akari.Display.Text.RangeShape.square;
  
  // See if we need to operate on characters
  if ( !params.basis || params.basis === "characters" )
  {
    return
    {
      select : function( time, linesContainer, callback )
      {
        propsBinder.update( time );
        
        // Keep track of current index to get the proportion
        var accumIndex = 0;
        var length = 0;
        
        // Iterate through the linesContainer a first time getting length
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          length += ( linesContainer.getChildAt( lineIndex ) ).numChildren;
        }
        
        // Iterate through the linesContainer a second time operating
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          var line = linesContainer.getChildAt( lineIndex );
          
          for ( var charIndex = 0; charIndex < line.numChildren; charIndex ++ )
          {
            callback( line.getChildAt( charIndex ), shapingFunc.apply( props, [ ( accumIndex + charIndex ) / length ] ) );
          }
          
          accumIndex += line.numChildren;
        }
      }
    };
  }
  else
  {
    return
    {
      select : function( time, linesContainer, callback )
      {
        propsBinder.update( time );
        
        // Iterate through the linesContainer operating
        for ( var lineIndex = 0; lineIndex < linesContainer.numChildren; lineIndex ++ )
        {
          var line = linesContainer.getChildAt( lineIndex );

          callback( line, shapingFunc.apply( props, [ lineIndex / linesContainer.numChildren ] ) );
        }
      }
    };
  }
};

/* Class: Animator
 * Used by DynamicVectorTextLayer for per-character animation.
 *
 * selector
 *   A Selector defining the effect range of this Animator.
 * bindings
 *   A set of Bindings defining behavior of characters within the effect range.
 * blendingFunc
 *   [default] function( value1, value2, effectFactor ) { return value1 + value2 * effectFactor; }
 *   Function for blending the value generated by animator with the original one.
 */
Akari.Display.Text.Animator = function( params )
{
  // An empty object for new properties for glyphs
  var props = {};
  var propsBinder = Akari.Utilities.Binder({ object : props, properties : params.bindings, overridePathCheck : true });

  var blendingFunc = params.blendingFunc || function( value1, value2, effectFactor ) { return value1 + value2 * effectFactor; };
  
  // Private function used as callback for Selector
  var selectCallback = function( object, effectFactor )
  {
    foreach( props, function( key, value )
    {
      // Check if it exists anyway, we can still use nonexistents and Links since those are processed by the Binder
      if ( object.hasOwnProperty( key ) )
      {
        // No checking here since try/catches just don't work. It's the user's responsibility now
        object[ key ] = blendingFunc( object[ key ], props[ key ], effectFactor );
      }
    });
  };
  
  return
  {
    apply : function( time, linesContainer )
    {
      propsBinder.update( time );

      params.selector.select( time, linesContainer, selectCallback );
    }
  };
};

/* Class: DynamicVectorTextLayer
 * A type of layer specialized to display basic dynamic vector text (huge sizes over 200px or exotic fonts).
 *
 * dictionary
 *   An Object containing functions with signature function( graphics ){ } for possible glyphs.
 *   Glyphs should be provided by user, be anchored at top-left and be of 200px in size.
 * textProperties
 *   [default] { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" }
 *   An Object, containing values or Bindings for vector text properties: horizontalAlign, verticalAlign, fontSize, letterSpacing, lineHeight, text.
 *   If fixedWidth is true, spacing between characters will always be fontSize + letterSpacing or ( fontSize / 2 ) + letterSpacing depending on which the actual width is nearer to.
 * inPoint
 *   A Number, the time (in milliseconds) at which the layers enters.
 * outPoint
 *   A Number, the time (in milliseconds) at which the layers exits.
 * properties
 *   [default] {}
 *   An Object, containing values or Bindings for each AS3 property.
 * animators
 *   [default] []
 *   Animators for per-character animation. Using animators will cause the glyphs be re-arranged every frame due to the nature of it.
 */
Akari.Display.Text.DynamicVectorTextLayer = function( params )
{
  // Create Sprites for alignment
  var linesContainer = Akari.Display.Sprite();
  var alignmentContainer = Akari.Display.Sprite();
  alignmentContainer.addChild( linesContainer );
  
  // Create objects for binding and change detection, due to lack of property getter / setters.
  var lastTextProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  
  var textProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  var textPropertiesBinder = Akari.Utilities.Binder({ object : textProperties, properties : params.textProperties || {} });
  
  var animators = params.animators || [];
  
  var layer = Akari.Display.Layer(
  {
    source : alignmentContainer,
    inPoint : params.inPoint,
    outPoint : params.outPoint,
    properties : params.properties
  });
  
  // Simulate inheritance by making a backup of update function.
  var baseUpdate = Akari.Utilities.Factory.clone( layer.update, layer );
  
  layer.update = function( time )
  {
    baseUpdate( time );
      
    // Update binder and check if anything changes
    textPropertiesBinder.update( time, layer.getBinderScope() );

    var needGlyphReset = ( textProperties.text != lastTextProperties.text );
    var needGlyphAdjust = ( params.animators.length > 0 ) || needGlyphReset || ( textProperties.letterSpacing != lastTextProperties.letterSpacing ) || ( textProperties.fontSize != lastTextProperties.fontSize );
    var needAlignmentAdjust = ( params.animators.length > 0 ) || needGlyphAdjust || ( textProperties.horizontalAlign != lastTextProperties.horizontalAlign ) || ( textProperties.verticalAlign != lastTextProperties.verticalAlign ) || ( textProperties.lineHeight != lastTextProperties.lineHeight );

    if ( needAlignmentAdjust ) lastTextProperties = Akari.Utilities.Factory.clone( textProperties );

    // Reset Glyphs if needed (most expensive)
    if ( needGlyphReset )
    {
      while ( linesContainer.numChildren > 0 ) linesContainer.removeChildAt( 0 );
      
      // Split text into lines to process
      var lines = textProperties.text.split( "\n" );
      
      for ( var numLine = 0; numLine < lines.length; numLine ++ )
      {
        // For each line create a new Sprite to contain glyphs
        var lineSprite = Akari.Display.Sprite();
        
        for ( var numChar = 0; numChar < lines[ numLine ].length; numChar ++ )
        {
          // Create glyphs and put them in current line. Position does not matter since it will be corrected afterwards.
          var glyphShape = Akari.Display.Shape();
          params.dictionary[ lines[ numLine ].charAt( numChar ) ]( glyphShape.graphics );
          lineSprite.addChild( glyphShape );
        }
        
        linesContainer.addChild( lineSprite );
      }
    }

    // Adjust glyphs if needed
    if ( needGlyphAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        var accumulativeX = 0;
        
        for ( var numChar = 0; numChar < lineSprite.numChildren; numChar ++ )
        {
          var glyph = lineSprite.getChildAt( numChar );

          // Reset glyph positioning, so that glyphs don't "drift away" with animators.
          glyph.transform.matrix3D = null;
          mx = glyph.transform.matrix;
          mx.identity();
          glyph.transform.matrix = mx;
          
          glyph.x = accumulativeX;
          glyph.scaleX = glyph.scaleY = textProperties.fontSize / 200.0;
          
          if ( textProperties.fixedWidth )
          {
            var nwFactor = Math.round( glyph.width / textProperties.fontSize );
            accumulativeX += textProperties.fontSize * ( nwFactor / 2 + 0.5 ) + textProperties.letterSpacing;
          }
          else
          {
            accumulativeX += glyph.width + textProperties.letterSpacing;
          }
        }
      }
    }
    
    // Adjust alignment if needed
    if ( needAlignmentAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        
        // Set line height and alignment
        switch ( textProperties.horizontalAlign )
        {
          case "left":
            lineSprite.x = 0;
            break;
          case "right":
            lineSprite.x = - lineSprite.width;
            break;
          case "center":
            lineSprite.x = - lineSprite.width / 2;
            break;
        }
        lineSprite.y = numLine * textProperties.lineHeight;
      }
      
      // Set vertical alignment
      switch ( textProperties.verticalAlign )
      {
        case "top":
          linesContainer.y = 0;
          break;
        case "bottom":
          linesContainer.y = - linesContainer.height;
          break;
        case "center":
          linesContainer.y = - linesContainer.height / 2;
          break;
      }
    }

    // Deal with animators if needed
    if ( params.animators.length > 0 )
    {
      for ( var animatorIndex = 0; animatorIndex < params.animators.length; animatorIndex ++ )
      {
        params.animators[ animatorIndex ].apply( time, linesContainer );
      }
    }
  };
    
  /* Function: clone
   * Custom clone function for binder to work.
   */
  layer.clone = function()
  {
    return Akari.Display.Text.DynamicVectorTextLayer( Akari.Utilities.Factory.clone( params ) );
  };

  // Update Layer for a first time to prevent flashing
  layer.update( params.inPoint );
  
  return layer;
};